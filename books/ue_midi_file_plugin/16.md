---
title: Blueprintノードの概略
---

# 工事中

[前回のチャプター](./15) では、MIDIファイルに関する以下の操作を実装しました：

- MIDIファイルの読み込み
- `.uasset` として保存
- `.uasset` から MIDI データを読み込む

いよいよ Blueprint ノードの作成に取り掛かりますが、その前に Blueprint ノードの実装方法について確認しておきましょう。

## Blueprint ノード = C++のクラスメンバー

Blueprint ノードは、C++で定義された関数やプロパティを Blueprint 上で視覚的に扱えるようにしたものです。
そのため、ノードとして利用するには、対応するC++関数として実装し、必要なマクロを付与することで Blueprint からアクセスできるようになります。

```cpp
UFUNCTION(BlueprintCallable, Category="MyPlugin")
void MyFunction();
```


## インスタンスメンバーと static メンバー

C++の関数は通常、クラスのインスタンス(実体)を通して呼び出されます。
このコンテキストを Blueprint 上では、メンバ関数のインスタンスを接続することで表現します。

一方で、C++ には `static` なメンバも存在します。これらのノードはインスタンスを接続せずに使用できます。

インスタンスを必要とするノードでは、メンバ変数の状態に応じた動作を実装することができます。
一方、 `static` なノードではメンバ変数が使用できないため、クラス内部の状態に依存した処理が実装できないという制約が生まれます。
さらに、必要な情報をすべて関数の引数として渡す必要があるため、設計が煩雑になったり、
場合によっては本来カプセル化すべきメンバ変数を `public` にせざるを得ない場面も出てくるかもしれません。  
結果として、クラス設計の堅牢性が損なわれる可能性もあります。

このため、関数の性質に応じて「static にするかどうか」を慎重に判断する必要があります。

## インスタンスとガベージコレクション

Unreal Engine では、インスタンスはガベージコレクション (GC) によって自動的に破棄される可能性があります。
ガベージコレクションからインスタンスを守る簡単な方法は、Blueprint 上で変数を作成し、インスタンスを保持する方法です。

## インスタンスメンバーノードと static メンバーノードの例

以下の図は、 `CreateMidiFileSequence` でインスタンスを生成し、
GC対策として変数に保持した上でメンバ関数を呼び出している一連の流れを示しています。

![staticメンバ関数、インスタンスメンバ関数、GC対策の例](/images/books/ue_midi_file_plugin/16/01.png)

右側のノード群 (`Start Sequence`, `Stop Sequence` など)は、`MidiFileSequence` クラスのインスタンスメンバ関数です。

```cpp
UCLASS(BlueprintType)
class MIDIFILESEQUENCEMODULE_API UMidiFileSequence : public UObject
{
public:
...
	UFUNCTION(BlueprintCallable, Category = "Midi File Plugin")
	void StartSequence(const double offset);

	UFUNCTION(BlueprintCallable, Category = "Midi File Plugin")
	void StopSequence();

	UFUNCTION(BlueprintCallable, Category = "Midi File Plugin")
	TArray<UMidiEventWrapper*> Sequence(bool& bEOF);
...
};
```

これらノードは入力に、`MidiFileSequence` のインスタンスを接続しています。

左側のノード (`CreateMidiFileSequence`)は、`MidiFileObjectBlueprint` クラスの static メンバ関数です。

```cpp
UCLASS()
class MIDIFILEOBJECTBLUEPRINTMODULE_API UMidiFileObjectBlueprint : public UBlueprintFunctionLibrary
{
...
public:
	UFUNCTION(BlueprintCallable, Category = "Midi File Asset")
	static UMidiFileSequence* CreateMidiFileSequence(UMidiFileObject* MidiFileObject);
};
...
```

この関数は、`MidiFileObject` を引数として受け取り、`MidiFileSequence` のインスタンスを生成して返します。

中央の処理では、生成された `MidiFileSequence` を Blueprint 変数に代入することで、
GC による破棄を防ぎつつ、後続のノード に中継しています。

## まとめ

Blueprint ノードは、C++ 側で関数やプロパティとして実装し、適切なマクロを指定することで利用可能になります。
インスタンスメンバのノードはクラスインスタンスを接続する必要があります。その分、メンバ変数を利用した動作を実装することが可能になります。
static メンバのノードはメンバ変数の利用が不可能になる代わりに、クラスインスタンスを接続する必要がありません。

クラスインスタンスがガベージコレクションによって破棄されてしまう場合、変数に保持することで保護することができます。

[次のチャプター](./17) では static メンバ関数を保持する `MidiFileObjectBlueprint` クラスと、
Midiシーケンスの制御を行う `MidiFileSequence` クラスを作成します。