---
title: MidiFileObjectにuassetとして保存する機能を作成する
---

[前回のチャプター](./14)では、`MidiFileObjectFactoryModule` のパス設定を行い、MIDIファイルのインポート機能の実装が完了しました。
このチャプターではMIDIファイルを `uasset` として保存・再読み込みするための機能を実装します。

## 処理の流れと実装方針

Unreal Engine の `UObject` は、`Serialize(FArchive& Ar)` をオーバーライドすることでシリアライズ(保存・復元)処理をカスタマイズできます。  
これを利用して、MIDIデータを `TArray<uint8>` として `uasset` に保存・読み込みできるようにします。

参考: https://historia.co.jp/archives/1457/

## MIDIデータの書き出しに必要な変換


### `smf::MidiFile::write(std::ostream&)`

MIDIファイルを出力するには、`smf::MidiFile` の `write(std::ostream&)` 関数を使用します。

https://github.com/craigsapp/midifile/blob/98917df5b1bf0d6e8d4c0e5fff86d6b05343e793/src/MidiFile.cpp#L572

### `std::ostream` → `TArray<uint8>` への変換

C++ 標準の `std::streambuf` を継承し、書き込まれた内容を `TArray<uint8>` に蓄積するクラスを実装します。  
このクラスでは、コンストラクタで書き込み先の `TArray<uint8>&` を受け取り保持します。

書き込み動作に対応するために、以下の2つの関数をオーバーライドしています:

- `xsputn`
  * 複数バイトの連続書き込み時に呼ばれます
- `overflow`
  * 1文字書き込み、または内部バッファが不足した場合に呼ばれます

なお、この実装ではコンストラクタで `setp` によるバッファ指定をしていないため、1文字書き込みに `sputc` が使われた場合は 必ず `overflow` を経由します。

`overflow` は `virtual` 修飾されており、派生クラスでのオーバーライドが公式に想定されていますが、
`sputc` 自体はそうではありません。`xsputn` のような `protected virtual` な `xsputc` という関数もありません。
そのため、1文字処理は `overflow` を通じての実装になっています。

参考:
* https://qiita.com/yumimatoba14/items/c4ac015a09dea2b54bf3
* https://select766.hatenablog.com/entry/2022/10/22/190100
* https://cpprefjp.github.io/reference/streambuf/basic_streambuf/sputc.html
* https://cpprefjp.github.io/reference/streambuf/basic_streambuf/sputn.html
* https://cpprefjp.github.io/reference/streambuf/basic_streambuf/xsputn.html
* https://cpprefjp.github.io/reference/streambuf/basic_streambuf/overflow.html
* https://cpprefjp.github.io/reference/streambuf/basic_streambuf/setp.html

実際のコードは下記、 `MidiFileObject.cpp` の方を参照ください。

## クラス定義( `MidiFileObject.h` )の変更

```diff cpp
#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MidiFile.h"
#include "MidiFileObject.generated.h"

/**
 * 
 */
UCLASS()
class MIDIFILEPLUGIN_API UMidiFileObject : public UObject
{
public:
	GENERATED_BODY()

+	virtual void Serialize(FArchive& Ar) override;

	const bool includeBinary(const uint8*& start, const uint8* end);

private:
	smf :: MidiFile _midi;
};
```

## 更新した `MidiFileObject.cpp` の全貌

```diff cpp
/* 省略 */

struct inputBuffer : public std::streambuf{ /* 省略 */};

+ struct outputBuffer : public std::streambuf
+ {
+ 	explicit outputBuffer(TArray<uint8>& data) : _data(data){}
+ 	
+ 	protected:
+ 	virtual int_type overflow(int_type ch = traits_type::eof()) override {
+ 		if (ch != traits_type::eof()) {
+ 			_data.Add(static_cast<uint8>(ch));
+ 			return ch;
+ 		}
+ 		return traits_type::eof();
+ 	}
+ 
+ 	virtual std::streamsize xsputn(const char* s, std::streamsize count) override {
+ 		if (count > 0)
+ 			_data.Append(reinterpret_cast<const uint8*>(s), count);
+ 		return count;
+ 	}
+ 
+ 	private:
+ 	TArray<uint8>& _data;
+ };
+ 
+ void UMidiFileObject :: Serialize(FArchive& Ar){
+ 
+ 	Super :: Serialize(Ar);
+ 
+ 	if (Ar.IsSaving()){ // 1.
+ 		TArray<uint8> data;
+ 		outputBuffer outputbuf(data);
+ 		std :: ostream os(&outputbuf);
+ 
+ 		_midi.splitTracks(); // ch毎にトラックを分けた状態にする
+ 		_midi.write(os);
+ 
+ 		Ar << data;
+ 		return;
+ 	}
+ 
+ 	if (Ar.IsLoading()){ // 2.
+ 		TArray<uint8> data;
+ 		Ar << data;         // 気に食わないが入出力の演算子、方向が同じ
+ 
+ 		const uint8* start = data.GetData();
+ 		const uint8* end   = start + data.Num();
+ 		
+ 		includeBinary(start, end);
+ 	}
+ }

const bool UMidiFileObject :: includeBinary(const uint8*& start, const uint8* end){
    /* 省略 */
}
```

## 実装フローまとめ

1. `if (Ar.IsSaving()){...` 
    * `uasset` の保存処理です。`smf::MidiFile` から `std::ostream` 経由で `TArray<uint8>` にバイナリデータが書き込まれ、 `FArchive` が `uasset` として保存を行います。
2. `if (Ar.IsLoading()){...`
    * `uasset` からの読み込み処理です。 `FArchive` から `TArray<uint8>` に一度読み込み、 
  [チャプター13](./13) で作成した `includeBinary` を再利用しています。

## 次のチャプターへ

この実装により、MIDIファイルを `uasset` として保存・読み込みできるようになりました。  
[次のチャプター](./16) からは、いよいよBlueprintで再生するための機能をノード毎に作成していきます。


