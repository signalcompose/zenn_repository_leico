---
title : 再生機能の実装:Sequenceノード
---

[前回のチャプター](./20) では、`Start Sequence` と `Stop Sequence` ノードを作成し、再生制御の基本を整えました。  
このチャプターでは、実際にMIDIファイルを再生する `Sequence` ノードを実装します。

## `Sequence` ノードの仕様

![Sequence](/images/books/ue_midi_file_plugin/21/01.png)

- `UMidiFileSequence` オブジェクトを再生対象として受け取ります。
- 再生のトリガーは Blueprint の `Event Tick` などを想定しています。
- ノードが呼ばれるたびに、経過時間に基づいて未出力のMIDIイベントを抽出・出力します。
- 出力内容：
  - 再生対象となる `UMidiFilePluginMidiEvent` の配列
  - 再生終了判定用の `bEOF`（bool）フラグ

## `MidiFileSequence.h` の更新
```diff cpp
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MidiFileObject.h"
#include "MidiFilePluginMidiEvent.h"
#include "MidiFileSequence.generated.h"

/**
 * 
 */
+ UCLASS(BlueprintType)
class MIDIFILESEQUENCEMODULE_API UMidiFileSequence : public UObject
{

public:
	GENERATED_BODY()

	UMidiFileSequence();

	void SetMidiFileObject(UMidiFileObject* MidiFileObject);

	UFUNCTION(BlueprintCallable, Category = "Midi File Plugin")
	void StartSequence(const double offset);

	UFUNCTION(BlueprintCallable, Category = "Midi File Plugin")
	void StopSequence();

+	UFUNCTION(BlueprintCallable, Category = "Midi File Plugin")
+	TArray<UMidiFilePluginMidiEvent *> Sequence(bool& bEOF);



private:

	UMidiFileObject* _midiFileObject;

+	double _seekPositionSec;
+	double _startTimeOffsetSec;
+	double _startTimeSec;
+	int    _currentEventIndex;

	bool bProgress;
	
};
```

### 解説

- クラスに `BlueprintType` を付与：Blueprint変数として `UMidiFileSequence` を保持可能にします。変数に保持することにより、ガベージコレクションによって実行中のインスタンスが破棄されるのを防ぎます。
- `Sequence` 関数：MIDIイベント配列出力とファイル終端フラグ `bEOF` を返す構造で実装しています。
- 各再生関連の状態を保持するメンバー変数を追加。

### `MidiFileSequence.cpp`

```diff cpp
#include "MidiFileSequence.h"

UMidiFileSequence :: UMidiFileSequence(void) : 
      Super()
    , _midiFileObject(nullptr)
+    , _seekPositionSec   (0)
+    , _startTimeOffsetSec(0)
+    , _startTimeSec      (0)
+    , _currentEventIndex (0)
    , bProgress(false)
{}

void UMidiFileSequence :: SetMidiFileObject(UMidiFileObject* MidiFileObject){
    
    _midiFileObject = MidiFileObject;
}

void UMidiFileSequence :: StartSequence(const double startTimeOffsetSec){
    
    if(_midiFileObject == nullptr) {
		UE_LOG(LogTemp, Error, TEXT("[UMidiFileSequence :: StartSequence] : _midiFileObject == nullptr"));
        return;
    }

    if(bProgress == true)
        return;
 

+    _startTimeOffsetSec = startTimeOffsetSec;
+    _seekPositionSec    = _startTimeOffsetSec;
+    _startTimeSec       = FPlatformTime :: Seconds();
+    _currentEventIndex  = 0;
+
+    const smf :: MidiEventList& midiList = _midiFileObject -> _midi[0];
+
+    for(_currentEventIndex;; ++ _currentEventIndex){
+
+        if( _currentEventIndex >= midiList.size() ){
+		    UE_LOG(LogTemp, Error, TEXT("[UMidiFileSequence :: StartSequence] : _currentEventIndex >= midiList.size() "));
+            return;
+        }
+
+        if( midiList[_currentEventIndex].seconds >= _seekPositionSec )
+            break;
+    }

    bProgress = true;
}

void UMidiFileSequence :: StopSequence(void) {
    bProgress = false;
}


+ TArray<UMidiFilePluginMidiEvent*> UMidiFileSequence :: Sequence(bool& bEOF) {
+ 
+     TArray<UMidiFilePluginMidiEvent*> events;
+ 
+     if( _midiFileObject == nullptr )
+         return events;
+ 
+     if( ! bProgress)
+         return events;
+ 
+     const double currentTimeSec = FPlatformTime :: Seconds();
+     _seekPositionSec = currentTimeSec - _startTimeSec + _startTimeOffsetSec;
+ 
+     const smf :: MidiEventList& midiList = _midiFileObject -> _midi[0];
+ 
+     for(_currentEventIndex;; ++ _currentEventIndex){
+ 
+         if( _currentEventIndex >= midiList.size() ){
+             bEOF = true;
+             return events;
+         }
+ 
+         if( midiList[_currentEventIndex].seconds < _seekPositionSec ){
+             UMidiFilePluginMidiEvent *midiEvent = NewObject<UMidiFilePluginMidiEvent>();
+             midiEvent -> event = midiList[_currentEventIndex];
+             events.Add(midiEvent);
+             continue;
+         }
+         break;
+     }

      // MIDIイベント配列を画面に出力(デバッグ用で最終的に不要)
+     for(int32 index = 0 ; index < events.Num() ; ++ index){
+         if (GEngine)
+         {
+             FString Msg = FString :: Printf(
+                 TEXT("events[%d] : Note message ? %d"), index, events[index] -> event.isNote() // 表示メッセージ
+             );
+             GEngine->AddOnScreenDebugMessage(
+                 -1,                        // 表示スロットID（-1で自動）
+                 5.0f,                      // 表示時間（秒）
+                 FColor::Green,             // テキストの色
+                 Msg                        // 表示メッセージ
+             );
+         }
+     }
      // ここまで

+ 
+     bEOF = false;
+     return events;
+ }

```
## Blueprintでの再生例

以下のように Blueprint を構成することで、MIDIファイルを時間に応じて再生・処理できます。

![Blueprint](/images/books/ue_midi_file_plugin/21/02.png)
![実行例](/images/books/ue_midi_file_plugin/21/03.gif)


次のチャプターからは、MIDIメッセージのを処理するノードを作成します。