---
title: MidiFileObjectにMIDIファイルを読み込む機能を作成する
---

# 工事中

[前回のチャプター](./12)では、`MidiFileObjectFactory` クラスでMIDIファイルを読み込み、`MidiFileObject` を生成する処理を実装しました。  
このチャプターでは、`MidiFileObject` に `includeBinary` 関数を実装し、MIDIファイルの内容を実際に読み込む処理を行います。

## 処理の流れと実装方針

まず、`MidiFileObjectFactory::FactoryCreateBinary` の引数を確認します。

```cpp
UObject* UMidiFileObjectFactory::FactoryCreateBinary(..., const uint8*& Buffer, const uint8* BufferEnd, ...)
```

ここから、MIDIファイルのデータは `Buffer`（データの始点）と `BufferEnd`（終点）として受け取れることがわかります。  
この2つを `includeBinary(const uint8*& Start, const uint8* End)` のように受け取り、
内部でMIDIファイルを読み取れる形式に変換します。

### MIDIファイルの読み込みに必要な変換

`includeBinary` 関数では、外部ライブラリ `MidiFile` の機能を用いてMIDIデータを読み込みます。  
`MidiFile` は `std::istream` からデータを読み込む機能を提供しており、以下のような関数が用意されています：

https://github.com/craigsapp/midifile/blob/98917df5b1bf0d6e8d4c0e5fff86d6b05343e793/src/MidiFile.cpp#L94

つまり、`uint8` 配列を `std::istream` に変換できれば、読み込み可能になります。

### `uint8` 配列から `std::istream` への変換

`std::istream` を自前のメモリ上に構築するには、`std::streambuf` を継承したクラスを使うのが一般的なようです。
以下は、Stack Overflow で紹介されているその一例です：

```cpp
struct membuf : std::streambuf
{
    membuf(char* begin, char* end) {
        this->setg(begin, begin, end);
    }
};

int main()
{
    char buffer[] = "I'm a buffer with embedded nulls\0and line\n feeds";

    membuf sbuf(buffer, buffer + sizeof(buffer));
    std::istream in(&sbuf);
    ...
}
```

> https://stackoverflow.com/a/7782037

このように `membuf` を通して `char*` 配列から `std::istream` を構築できます。  
`uint8*` を `char*` に変換するには、`reinterpret_cast<char*>` を使います。

### まとめ：必要な変換の流れ

以下が、今回行うバイナリ読み込み処理の全体的な流れです：

| 種類         | 内容                                                |
|--------------|-----------------------------------------------------|
| 元データ     | `const uint8* Buffer`, `const uint8* BufferEnd`     |
| メモリ変換   | `reinterpret_cast<char*>(Buffer)` で `char*` に変換 |
| ストリーム化 | `membuf` -> `std::istream` を作成                   |
| 読み込み処理 | `MidiFile.read(std::istream&)` で読み込み           |

MidiFileが読める形が見えたため、 `MidiFileObject` クラスにこれらの機能を実装します。

## MidiFileObject.h の変更


`MidiFileObject.h` のクラス定義を以下のように変更します。
`readMidiFromRawData` 部分は後から追加する機能でも利用するため、読み込み用の処理を2段階に分けて書いています。


```cpp
UCLASS()
class MIDIFILEPLUGIN_API UMidiFileObject : public UObject
{
public:
	GENERATED_BODY()

	const bool includeBinary(const uint8*& start, const uint8* end);

private:
	const bool readMidiFromRawData(void);

	TArray<uint8> _rawData;
	smf :: MidiFile _midi;
	
};
```

```cpp
const bool includeBinary(const uint8*& start, const uint8* end);
```

外側から使う関数です。この関数で `_rawData` へ一度データをコピーします。

```cpp
const bool readMidiFromRawData(void);
```

実際に `_rawData` から `_midi` へデータを読み込む関数です。

```cpp
TArray<uint8> _rawData;
smf :: MidiFile _midi;
```

読み込み時にデータを一時格納する配列と実際に解析したデータを扱うMidiFileクラスです。
どちらも内部的にしか利用しないため `private` になっています。