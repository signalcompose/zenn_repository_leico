---
title: MidiFileObjectにMIDIファイルを読み込む機能を作成する
---

[前回のチャプター](./12)では、`MidiFileObjectFactory` クラスでMIDIファイルを読み込み、`MidiFileObject` を生成する処理を実装しました。  
このチャプターでは、`MidiFileObject` に `includeBinary` 関数を実装し、MIDIファイルの内容を実際に読み込む処理を行います。

## 処理の流れと実装方針

まず、`MidiFileObjectFactory::FactoryCreateBinary` の引数を確認します。

```cpp
UObject* UMidiFileObjectFactory::FactoryCreateBinary(..., const uint8*& Buffer, const uint8* BufferEnd, ...)
```

ここから、MIDIファイルのデータは `Buffer`（データの始点）と `BufferEnd`（終点）として受け取れることがわかります。  
この2つを `includeBinary(const uint8*& Start, const uint8* End)` のように受け取り、
内部でMIDIファイルを読み取れる形式に変換します。

### MIDIファイルの読み込みに必要な変換

`includeBinary` 関数では、外部ライブラリ `MidiFile` の機能を用いてMIDIデータを読み込みます。  
`MidiFile` は `std::istream` からデータを読み込む機能を提供しており、以下のような関数が用意されています：

https://github.com/craigsapp/midifile/blob/98917df5b1bf0d6e8d4c0e5fff86d6b05343e793/src/MidiFile.cpp#L94

つまり、`uint8` 配列を `std::istream` に変換できれば、読み込み可能になります。

### `uint8` 配列から `std::istream` への変換

`std::istream` を自前のメモリ上に構築するには、`std::streambuf` を継承したクラスを使うのが一般的なようです。
以下は、Stack Overflow で紹介されているその一例です：

```cpp
struct membuf : std::streambuf
{
    membuf(char* begin, char* end) {
        this->setg(begin, begin, end);
    }
};

int main()
{
    char buffer[] = "I'm a buffer with embedded nulls\0and line\n feeds";

    membuf sbuf(buffer, buffer + sizeof(buffer));
    std::istream in(&sbuf);
    ...
}
```

> https://stackoverflow.com/a/7782037

このように `membuf` を通して `char*` 配列から `std::istream` を構築できます。  
`uint8*` を `char*` に変換するには、`reinterpret_cast<char*>` を使います。

### まとめ：必要な変換の流れ

以下が、今回行うバイナリ読み込み処理の全体的な流れです：

| 種類         | 内容                                                |
|--------------|-----------------------------------------------------|
| 元データ     | `const uint8* Buffer`, `const uint8* BufferEnd`     |
| メモリ変換   | `reinterpret_cast<char*>(Buffer)` で `char*` に変換 |
| ストリーム化 | `membuf` -> `std::istream` を作成                   |
| 読み込み処理 | `MidiFile.read(std::istream&)` で読み込み           |

この流れに沿って、`MidiFileObject` クラスに機能を実装していきます。

## MidiFileObject.h の変更

以下はクラス定義の変更点です。 読み込み機能を2つの関数で実装しています。
内、`readMidiFromRawData` 部分は後から追加する機能でも利用します。


```cpp
UCLASS()
class MIDIFILEPLUGIN_API UMidiFileObject : public UObject
{
public:
	GENERATED_BODY()

	const bool includeBinary(const uint8*& start, const uint8* end);

private:
	const bool readMidiFromRawData(void);

	TArray<uint8> _rawData;
	smf :: MidiFile _midi;
	
};
```

### 各メンバーの解説

- `includeBinary(const uint8*& start, const uint8* end)`  
  外部から呼び出す関数で、MIDIファイルのバイナリデータを `_rawData` にコピーします。

- `readMidiFromRawData()`  
  `_rawData` から `smf::MidiFile` へ実際にデータを読み込む内部処理です。

- `_rawData`, `_midi`  
  バイナリデータと、パースされたMIDIデータ本体。外部からは使用されないため `private` としています。


## `MidiFileObject.cpp` の変更

以下が実装コードです。

```cpp

#include "MidiFileObject.h" //最初にインクルードしないとエラー

#include <streambuf>
#include <iostream>

struct inputBuffer : std::streambuf
{
    inputBuffer(char* begin, char* end) {
        this->setg(begin, begin, end);
    }
};

const bool UMidiFileObject :: includeBinary(const uint8*& start, const uint8* end){

	const int32 datasize = end - start;
	_rawData.Empty();
	_rawData.AddUninitialized(datasize);
	FMemory :: Memcpy(_rawData.GetData(), start, sizeof(uint8) * datasize);

	return readMidiFromRawData();
}

const bool UMidiFileObject :: readMidiFromRawData(void) {
	inputBuffer istreamBuf(
		reinterpret_cast<char*>(_rawData.GetData()),
		reinterpret_cast<char*>(_rawData.GetData() + _rawData.Num())
	);

	UE_LOG(LogTemp, Verbose, TEXT("rawData.Num : %d"), _rawData.Num());

	std :: istream istreamedData(&istreamBuf);

	if(_midi.read(istreamedData)){
	    _midi.joinTracks   ();
		_midi.sortTracks   ();
		_midi.linkNotePairs();
		_midi.doTimeAnalysis();
		UE_LOG(LogTemp, Verbose, TEXT("Load Success"));

		return true;
	}
	UE_LOG(LogTemp, Warning, TEXT("Load Failed"));

	return false;
}
```

## 実装詳細の補足

### `includeBinary`

```cpp
const int32 datasize = end - start;
_rawData.Empty();
_rawData.AddUninitialized(datasize);
FMemory :: Memcpy(_rawData.GetData(), start, sizeof(uint8) * datasize);

return readMidiFromRawData();
```

- バイナリの長さを計算し、`_rawData` を初期化・コピーしています。
- コピー後に `readMidiFromRawData` を呼び出して読み込みを実行します。


### `readMidiFromRawData`

```cpp
inputBuffer istreamBuf(...);
std :: istream istreamedData(&istreamBuf);
```

`_rawData` から `smf::MidiFile` に読み込ませるためのストリームバッファを構築しています。

```cpp
if(_midi.read(istreamedData)){
```

構築したストリームバッファこの行で読み込んでいます。

```cpp
_midi.joinTracks   ();
_midi.sortTracks   ();
_midi.linkNotePairs();
_midi.doTimeAnalysis();
```

MIDIデータの時間解析と、それに必要なトラック統合・ソート・ペアリング処理を行っています。

読み込みに必要なソースコードの変更は以上ですが、パスが通っていないためまだビルドが通りません。
ビルドを通すためのパス設定を[次のチャプター](./14)で行います。

