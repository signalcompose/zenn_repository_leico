---
title: MidiFileObjectにMIDIファイルを読み込む機能を作成する
---

# 工事中

[前回のチャプター](./12)では、`MidiFileObjectFactory` クラスでMIDIファイルを読み込み、`MidiFileObject` を生成する処理を実装しました。  
このチャプターでは、`MidiFileObject` に `includeBinary` 関数を実装し、MIDIファイルの内容を実際に読み込む処理を行います。

## 処理の流れと実装方針

まず、`MidiFileObjectFactory::FactoryCreateBinary` の引数を確認します。

```cpp
UObject* UMidiFileObjectFactory::FactoryCreateBinary(..., const uint8*& Buffer, const uint8* BufferEnd, ...)
```

ここから、MIDIファイルのデータは `Buffer`（データの始点）と `BufferEnd`（終点）として受け取れることがわかります。  
この2つを `includeBinary(const uint8*& Start, const uint8* End)` のように受け取り、
内部でMIDIファイルを読み取れる形式に変換します。

### MIDIファイルの読み込みに必要な変換

`includeBinary` 関数では、外部ライブラリ `MidiFile` の機能を用いてMIDIデータを読み込みます。  
`MidiFile` は `std::istream` からデータを読み込む機能を提供しており、以下のような関数が用意されています：

https://github.com/craigsapp/midifile/blob/98917df5b1bf0d6e8d4c0e5fff86d6b05343e793/src/MidiFile.cpp#L94

つまり、`uint8` 配列を `std::istream` に変換できれば、読み込み可能になります。

### `uint8` 配列から `std::istream` への変換

`std::istream` を自前のメモリ上に構築するには、`std::streambuf` を継承したクラスを使うのが一般的なようです。
以下は、Stack Overflow で紹介されているその一例です：

```cpp
struct membuf : std::streambuf
{
    membuf(char* begin, char* end) {
        this->setg(begin, begin, end);
    }
};

int main()
{
    char buffer[] = "I'm a buffer with embedded nulls\0and line\n feeds";

    membuf sbuf(buffer, buffer + sizeof(buffer));
    std::istream in(&sbuf);
    ...
}
```

> https://stackoverflow.com/a/7782037

このように `membuf` を通して `char*` 配列から `std::istream` を構築できます。  
`uint8*` を `char*` に変換するには、`reinterpret_cast<char*>` を使います。

### まとめ：必要な変換の流れ

以下が、今回行うバイナリ読み込み処理の全体的な流れです：

| 種類         | 内容                                                |
|--------------|-----------------------------------------------------|
| 元データ     | `const uint8* Buffer`, `const uint8* BufferEnd`     |
| メモリ変換   | `reinterpret_cast<char*>(Buffer)` で `char*` に変換 |
| ストリーム化 | `membuf` -> `std::istream` を作成                   |
| 読み込み処理 | `MidiFile.read(std::istream&)` で読み込み           |

MidiFileが読める形が見えたため、 `MidiFileObject` クラスにこれらの機能を実装します。

## MidiFileObject.h の変更

`MidiFileObject.h` のクラス定義を以下のように変更します。
`readMidiFromRawData` 部分は後から追加する機能でも利用するため、読み込み用の処理を2段階に分けて書いています。


```cpp
UCLASS()
class MIDIFILEPLUGIN_API UMidiFileObject : public UObject
{
public:
	GENERATED_BODY()

	const bool includeBinary(const uint8*& start, const uint8* end);

private:
	const bool readMidiFromRawData(void);

	TArray<uint8> _rawData;
	smf :: MidiFile _midi;
	
};
```

```cpp
const bool includeBinary(const uint8*& start, const uint8* end);
```

外側から使う関数です。この関数で `_rawData` へ一度データをコピーします。

```cpp
const bool readMidiFromRawData(void);
```

実際に `_rawData` から `_midi` へデータを読み込む関数です。

```cpp
TArray<uint8> _rawData;
smf :: MidiFile _midi;
```

読み込み時にデータを一時格納する配列と実際に解析したデータを扱うMidiFileクラスです。
どちらも内部的にしか利用しないため `private` になっています。

## `MidiFileObject.cpp` の変更

`MidiFileObject.cpp` に各関数を実装します。
以下のようなコードになります。

```cpp
#include <streambuf>
#include <iostream>

#include "MidiFileObject.h"

struct inputBuffer : std::streambuf
{
    inputBuffer(char* begin, char* end) {
        this->setg(begin, begin, end);
    }
};

const bool UMidiFileObject :: includeBinary(const uint8*& start, const uint8* end){

	const int32 datasize = end - start;
	_rawData.Empty();
	_rawData.AddUninitialized(datasize);
	FMemory :: Memcpy(_rawData.GetData(), start, sizeof(uint8) * datasize);

	return readMidiFromRawData();
}

const bool UMidiFileObject :: readMidiFromRawData(void) {
	inputBuffer istreamBuf(
		reinterpret_cast<char*>(_rawData.GetData()),
		reinterpret_cast<char*>(_rawData.GetData() + _rawData.Num())
	);

	UE_LOG(LogTemp, Verbose, TEXT("rawData.Num : %d"), _rawData.Num());

	std :: istream istreamedData(&istreamBuf);

	if(_midi.read(istreamedData)){
	    _midi.joinTracks   ();
		_midi.sortTracks   ();
		_midi.linkNotePairs();
		_midi.doTimeAnalysis();
		UE_LOG(LogTemp, Verbose, TEXT("Load Success"));

		return true;
	}
	UE_LOG(LogTemp, Warning, TEXT("Load Failed"));

	return false;
}
```

### `std :: istream` 用の準備

```cpp
#include <streambuf>
#include <iostream>
```

必要なヘッダファイルをインクルードしています。

```cpp
struct inputBuffer : std::streambuf
{
    inputBuffer(char* begin, char* end) {
        this->setg(begin, begin, end);
    }
};
```

`std :: streambuf` を継承した構造体を宣言しています。
配列の先頭と最後を受け取るコンストラクタを定義しています。

### `includeBinary` 関数の実装

以下のコードで `includeBinary` 関数の実装を行っています。

```cpp
const bool UMidiFileObject :: includeBinary(const uint8*& start, const uint8* end){

	const int32 datasize = end - start;
	_rawData.Empty();
	_rawData.AddUninitialized(datasize);
	FMemory :: Memcpy(_rawData.GetData(), start, sizeof(uint8) * datasize);

	return readMidiFromRawData();
}
```

```cpp
const int32 datasize = end - start;
```

配列の長さを計算しています。

```cpp
_rawData.Empty();
_rawData.AddUninitialized(datasize);
```

`_rawData` にデータをコピーする準備です。`_radData` を空配列にした後、
計算した大きさにサイズ変更しています。

```cpp
FMemory :: Memcpy(_rawData.GetData(), start, sizeof(uint8) * datasize);
```

`_rawData` に取得した配列の内容をコピーしています。

```cpp
return readMidiFromRawData();
```

`readMidiFromRawData` の結果を返しています。
`_rawData` はこの中で処理されます。

### `readMidiFromRawData` 関数の実装

以下のコードで `readMidiFromRawData` 関数の実装を行っています。

```cpp
const bool UMidiFileObject :: readMidiFromRawData(void) {
	inputBuffer istreamBuf(
		reinterpret_cast<char*>(_rawData.GetData()),
		reinterpret_cast<char*>(_rawData.GetData() + _rawData.Num())
	);

	UE_LOG(LogTemp, Verbose, TEXT("rawData.Num : %d"), _rawData.Num());

	std :: istream istreamedData(&istreamBuf);

	if(_midi.read(istreamedData)){
	    _midi.joinTracks   ();
		_midi.sortTracks   ();
		_midi.linkNotePairs();
		_midi.doTimeAnalysis();
		UE_LOG(LogTemp, Verbose, TEXT("Load Success"));

		return true;
	}
	UE_LOG(LogTemp, Warning, TEXT("Load Failed"));

	return false;
}
```

```cpp
inputBuffer istreamBuf(
	reinterpret_cast<char*>(_rawData.GetData()),
	reinterpret_cast<char*>(_rawData.GetData() + _rawData.Num())
);
```

`std :: istream` 向けのデータを作成しています。
ここで先程宣言した構造体を使います。

```cpp
UE_LOG(LogTemp, Verbose, TEXT("rawData.Num : %d"), _rawData.Num());
```

`_rawData` のサイズを表示しています。

```cpp
std :: istream istreamedData(&istreamBuf);
```

MidiFile 入力用の `std :: istream` を先ほどの構造体から作成しています。

```cpp
if(_midi.read(istreamedData)){
    _midi.joinTracks   ();
	_midi.sortTracks   ();
	_midi.linkNotePairs();
	_midi.doTimeAnalysis();
	UE_LOG(LogTemp, Verbose, TEXT("Load Success"));

	return true;
}
```

`std :: istream` からMidiデータを読み込み、成功した場合は以下の処理を行います。

1. channel 毎の配列になっているデータを1つの配列に統合します
2. 配列内のノートをタイミングの早い方からソートします
3. ノートオン・ノートオフのペアを作成します
4. ノートのタイミングをmsecで計算します。この関数のためにソートやペアの検出を行います

ロードが正常に終了したことをログ出力し、 `true` を返します。

```cpp
UE_LOG(LogTemp, Warning, TEXT("Load Failed"));

return false;
```

読み込みが失敗した時の処理です。失敗を警告し、 `false` を返します。